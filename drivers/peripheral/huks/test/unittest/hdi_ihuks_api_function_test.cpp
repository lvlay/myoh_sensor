/*
 * Copyright (c) 2023 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <gtest/gtest.h>
#include <gtest/hwext/gtest-multithread.h>
#include <vector>
#include <unistd.h>
#include <securec.h>

#include "v1_0/ihuks.h"
#include "v1_0/ihuks_types.h"
#include "huks_sa_type.h"
#include "huks_hdi_test_util.h"

using namespace testing;
using namespace testing::ext;
using namespace testing::mt;
namespace Unittest::HuksHdiTest {
static struct IHuks *g_huksHdiProxy = nullptr;

const static uint8_t g_importKeyAlias[] = {
    0x74, 0x65, 0x73, 0x74, 0x5F, 0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74, 0x5F, 0x6B, 0x65, 0x79, 0x00
};

static uint8_t g_importParamSet[] = {
    0x8C, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00,
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00,
    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x27, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00,
    0x04, 0x00, 0x00, 0x00, 0x38, 0x3E, 0x86, 0xF7, 0x2E, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x75, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00,
    0xFB, 0x60, 0x01, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const static uint8_t g_importKey[] = {
    0x17, 0xD6, 0x23, 0xCB, 0xA7, 0x05, 0x60, 0x22, 0xC1, 0x35, 0xCD, 0x3F, 0x30, 0x2D, 0xF6, 0x31,
};

const static uint8_t g_importOutKey[] = {
    0x1C, 0x01, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x27, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x08, 0xA1, 0x88, 0xF7, 0x2E, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x75, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0xFB, 0x60, 0x01, 0x30, 0x00, 0x00, 0x00, 0x00, 0x17, 0x27, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x27, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x27, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEF, 0x03, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x27, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 
    0x40, 0x00, 0x00, 0x00, 0x0C, 0xA1, 0x88, 0xF7, 0x00, 0x00, 0x00, 0x00, 0x58, 0x14, 0xBA, 0x89, 
    0x77, 0xBB, 0x5B, 0x03, 0x70, 0x70, 0x7A, 0x17, 0x88, 0x5F, 0x69, 0xBF, 0x6A, 0xCD, 0x50, 0xCC, 
    0xE0, 0xA2, 0x8F, 0x7C, 0x0F, 0x80, 0x74, 0x8F, 0x30, 0xA5, 0x1B, 0x9C, 0x74, 0x7F, 0x87, 0x5F, 
    0x8F, 0x07, 0x5B, 0xEF, 0x83, 0x3A, 0x40, 0x21, 0x10, 0x00, 0x00, 0x00, 0x6D, 0xE9, 0x0C, 0x45, 
    0x1A, 0x10, 0xA5, 0x63, 0xF2, 0xEA, 0x05, 0x98, 0x70, 0x86, 0x4A, 0xD5,
};

const static uint8_t g_generateKeyAlias[] = {
    0x48, 0x6B, 0x73, 0x41, 0x45, 0x53, 0x43, 0x69, 0x70, 0x68, 0x65, 0x72, 0x4B, 0x65, 0x79, 0x41,
    0x6C, 0x69, 0x61, 0x73, 0x54, 0x65, 0x73, 0x74, 0x30, 0x30, 0x31,
};

static uint8_t g_generateParamSet[] = {
    0x8C, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x27, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x28, 0x3E, 0x86, 0xF7, 0x2E, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x75, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0xFB, 0x60, 0x01, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const static uint8_t g_generateOutKey[] = {
    0x1C, 0x01, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x27, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0xE8, 0xA0, 0x88, 0xF7, 0x2E, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x75, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0xFB, 0x60, 0x01, 0x30, 0x00, 0x00, 0x00, 0x00, 0x17, 0x27, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x27, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x27, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEF, 0x03, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x27, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 
    0x40, 0x00, 0x00, 0x00, 0xEC, 0xA0, 0x88, 0xF7, 0x00, 0x00, 0x00, 0x00, 0x4D, 0x07, 0xB4, 0x87, 
    0xF1, 0x94, 0x9A, 0x2A, 0x8A, 0xD4, 0xFE, 0x57, 0xF0, 0x5E, 0xE6, 0x96, 0x50, 0x7C, 0x20, 0x7E, 
    0xC2, 0x5D, 0x42, 0x6E, 0x68, 0x2C, 0x9D, 0xC5, 0x79, 0x0E, 0x16, 0x72, 0x45, 0x2F, 0x1A, 0xA8, 
    0x2D, 0x18, 0x25, 0x9C, 0x86, 0xA3, 0x4C, 0x57, 0x10, 0x00, 0x00, 0x00, 0xE7, 0xF8, 0x6F, 0x32, 
    0x11, 0xEC, 0xF8, 0x66, 0x05, 0xD0, 0x1F, 0x38, 0xAD, 0xE1, 0xF3, 0x04,
};

static uint8_t g_initParamSet[] = {
    0xBC, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 
    0x10, 0x00, 0x00, 0x00, 0x58, 0x3E, 0x86, 0xF7, 0x11, 0x27, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0x68, 0x3E, 0x86, 0xF7, 0x2E, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x75, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0xFB, 0x60, 0x01, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

const static uint8_t g_initKey[] = {
    0x1C, 0x01, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x27, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 
    0x04, 0x00, 0x00, 0x00, 0xE8, 0xA0, 0x88, 0xF7, 0x2E, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x75, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0xFB, 0x60, 0x01, 0x30, 0x00, 0x00, 0x00, 0x00, 0x17, 0x27, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x27, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x27, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEF, 0x03, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
    0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x27, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 
    0x40, 0x00, 0x00, 0x00, 0xEC, 0xA0, 0x88, 0xF7, 0x00, 0x00, 0x00, 0x00, 0x4D, 0x07, 0xB4, 0x87, 
    0xF1, 0x94, 0x9A, 0x2A, 0x8A, 0xD4, 0xFE, 0x57, 0xF0, 0x5E, 0xE6, 0x96, 0x50, 0x7C, 0x20, 0x7E, 
    0xC2, 0x5D, 0x42, 0x6E, 0x68, 0x2C, 0x9D, 0xC5, 0x79, 0x0E, 0x16, 0x72, 0x45, 0x2F, 0x1A, 0xA8, 
    0x2D, 0x18, 0x25, 0x9C, 0x86, 0xA3, 0x4C, 0x57, 0x10, 0x00, 0x00, 0x00, 0xE7, 0xF8, 0x6F, 0x32, 
    0x11, 0xEC, 0xF8, 0x66, 0x05, 0xD0, 0x1F, 0x38, 0xAD, 0xE1, 0xF3, 0x04,
};

class HuksHdiApiTest : public testing::Test {
public:
    static void SetUpTestCase(void);

    static void TearDownTestCase(void);

    void SetUp();

    void TearDown();
};

void HuksHdiApiTest::SetUpTestCase(void)
{
    g_huksHdiProxy = IHuksGetInstance("hdi_service", true);
    int32_t ret = g_huksHdiProxy->ModuleInit(g_huksHdiProxy);
    HUKS_TEST_LOG_I("ModuleInit = %d", ret);
}

void HuksHdiApiTest::TearDownTestCase(void)
{
    if (g_huksHdiProxy != nullptr) {
        IHuksReleaseInstance("hdi_service", g_huksHdiProxy, true);
        g_huksHdiProxy = nullptr;
    }
}

void HuksHdiApiTest::SetUp()
{
}

void HuksHdiApiTest::TearDown()
{
}

#define HKS_TAG_TYPE_MASK (0xF << 28)
#define HKS_TAG_TYPE_BYTES (5 << 28)

static uint32_t GetTagType(uint32_t tag)
{
    return (tag & (uint32_t)HKS_TAG_TYPE_MASK);
}

static inline bool IsAdditionOverflow(uint32_t a, uint32_t b)
{
    return (UINT32_MAX - a) < b;
}

static int32_t HuksFreshParamSet(struct HksParamSet *paramSet, bool isCopy)
{
    uint32_t size = paramSet->paramSetSize;
    uint32_t offset = sizeof(struct HksParamSet) + sizeof(struct HksParam) * paramSet->paramsCnt;

    for (uint32_t i = 0; i < paramSet->paramsCnt; i++) {
        if (offset > size) {
            return HUKS_FAILURE;
        }
        if (GetTagType(paramSet->params[i].tag) == HKS_TAG_TYPE_BYTES) {
            if (IsAdditionOverflow(offset, paramSet->params[i].blob.size)) {
                return HUKS_FAILURE;
            }

            if (isCopy && (memcpy_s((uint8_t *)paramSet + offset, size - offset,
                paramSet->params[i].blob.data, paramSet->params[i].blob.size) != EOK)) {
                return HUKS_FAILURE;
            }
            paramSet->params[i].blob.data = (uint8_t *)paramSet + offset;
            offset += paramSet->params[i].blob.size;
        }
    }

    if (paramSet->paramSetSize != offset) {
        return HUKS_FAILURE;
    }
    return HUKS_SUCCESS;
}

/**
 * @tc.name: HuksHdiApiTest.HdiFuncPointerTest001
 * @tc.desc: Test hdi func pointer whether nullptr;
 * @tc.require:issueI77AT9
 * @tc.type: FUNC
 */
HWTEST_F(HuksHdiApiTest, HdiFuncPointerTest001, TestSize.Level0)
{
    ASSERT_NE(g_huksHdiProxy, nullptr);
    ASSERT_NE(g_huksHdiProxy->ModuleInit, nullptr);
    ASSERT_NE(g_huksHdiProxy->ModuleDestroy, nullptr);
    ASSERT_NE(g_huksHdiProxy->GenerateKey, nullptr);
    ASSERT_NE(g_huksHdiProxy->ImportKey, nullptr);
    ASSERT_NE(g_huksHdiProxy->ImportWrappedKey, nullptr);
    ASSERT_NE(g_huksHdiProxy->ExportPublicKey, nullptr);
    ASSERT_NE(g_huksHdiProxy->Init, nullptr);
    ASSERT_NE(g_huksHdiProxy->Update, nullptr);
    ASSERT_NE(g_huksHdiProxy->Finish, nullptr);
    ASSERT_NE(g_huksHdiProxy->Abort, nullptr);
    ASSERT_NE(g_huksHdiProxy->CheckKeyValidity, nullptr);
    ASSERT_NE(g_huksHdiProxy->AttestKey, nullptr);
    ASSERT_NE(g_huksHdiProxy->GenerateRandom, nullptr);
    ASSERT_NE(g_huksHdiProxy->Sign, nullptr);
    ASSERT_NE(g_huksHdiProxy->Verify, nullptr);
    ASSERT_NE(g_huksHdiProxy->Encrypt, nullptr);
    ASSERT_NE(g_huksHdiProxy->Decrypt, nullptr);
    ASSERT_NE(g_huksHdiProxy->AgreeKey, nullptr);
    ASSERT_NE(g_huksHdiProxy->DeriveKey, nullptr);
    ASSERT_NE(g_huksHdiProxy->Mac, nullptr);
    ASSERT_NE(g_huksHdiProxy->UpgradeKey, nullptr);
    ASSERT_NE(g_huksHdiProxy->ExportChipsetPlatformPublicKey, nullptr);
    ASSERT_NE(g_huksHdiProxy->GetVersion, nullptr);
}

/**
 * @tc.name: HuksHdiApiTest.ApiPassthroughTest001
 * @tc.desc: Test Generate key with current software huks driver;
 * @tc.require:issueI77AT9
 * @tc.type: FUNC
 */
HWTEST_F(HuksHdiApiTest, ApiPassthroughTest001, TestSize.Level0)
{
    ASSERT_NE(g_huksHdiProxy, nullptr);
    ASSERT_NE(g_huksHdiProxy->GenerateKey, nullptr);
    struct HuksBlob keyAlias = {
        .data = (uint8_t *)g_generateKeyAlias,
        .dataLen = sizeof(g_generateKeyAlias)
    };
    uint8_t keyBuff[1] = {0};
    struct HuksBlob key = {
        .data = keyBuff,
        .dataLen = sizeof(keyBuff)
    };
    int ret = HuksFreshParamSet((struct HksParamSet *)g_generateParamSet, false);
    ASSERT_EQ(ret, HUKS_SUCCESS);
    struct HuksParamSet paramSet = {
        .data = (uint8_t *)g_generateParamSet,
        .dataLen = sizeof(g_generateParamSet)
    };
    uint8_t outKeyBuffer[512];
    struct HuksBlob outKey = {
        .data = outKeyBuffer,
        .dataLen = sizeof(outKeyBuffer)
    };
    ret = g_huksHdiProxy->GenerateKey(g_huksHdiProxy, &keyAlias, &paramSet, &key, &outKey);
    ASSERT_EQ(ret, HUKS_SUCCESS);
    ASSERT_EQ(outKey.dataLen, sizeof(g_generateOutKey));
}

/**
 * @tc.name: HuksHdiApiTest.ApiPassthroughTest002
 * @tc.desc: Test Import key with current software huks driver(hardcoded root key);
 * @tc.require:issueI77AT9
 * @tc.type: FUNC
 */
HWTEST_F(HuksHdiApiTest, ApiPassthroughTest002, TestSize.Level0)
{
    ASSERT_NE(g_huksHdiProxy, nullptr);
    ASSERT_NE(g_huksHdiProxy->ImportKey, nullptr);
    struct HuksBlob keyAlias = {
        .data = (uint8_t *)g_importKeyAlias,
        .dataLen = sizeof(g_importKeyAlias)
    };
    struct HuksBlob key = {
        .data = (uint8_t *)g_importKey,
        .dataLen = sizeof(g_importKey)
    };
    
    int ret = HuksFreshParamSet((struct HksParamSet *)g_importParamSet, false);
    ASSERT_EQ(ret, HUKS_SUCCESS);
    struct HuksParamSet paramSet = {
        .data = (uint8_t *)g_importParamSet,
        .dataLen = sizeof(g_importParamSet)
    };
    uint8_t outKeyBuffer[512];
    struct HuksBlob outKey = {
        .data = outKeyBuffer,
        .dataLen = sizeof(outKeyBuffer)
    };
    ret = g_huksHdiProxy->ImportKey(g_huksHdiProxy, &keyAlias, &key, &paramSet, &outKey);
    ASSERT_EQ(ret, HUKS_SUCCESS);
    ASSERT_EQ(outKey.dataLen, sizeof(g_importOutKey));
}

/**
 * @tc.name: HuksHdiApiTest.ApiPassthroughTest003
 * @tc.desc: Test init key with current software huks driver(hardcoded root key);
 * @tc.require:issueI77AT9
 * @tc.type: FUNC
 */
HWTEST_F(HuksHdiApiTest, ApiPassthroughTest003, TestSize.Level0)
{
    ASSERT_NE(g_huksHdiProxy, nullptr);
    ASSERT_NE(g_huksHdiProxy->Init, nullptr);
    struct HuksBlob key = {
        .data = (uint8_t *)g_initKey,
        .dataLen = sizeof(g_initKey)
    };
    int ret = HuksFreshParamSet((struct HksParamSet *)g_initParamSet, false);
    ASSERT_EQ(ret, HUKS_SUCCESS);
    struct HuksParamSet paramSet = {
        .data = (uint8_t *)g_initParamSet,
        .dataLen = sizeof(g_initParamSet)
    };
    uint8_t outHandleBuffer[12];
    struct HuksBlob outHandle = {
        .data = outHandleBuffer,
        .dataLen = sizeof(outHandleBuffer)
    };
    uint8_t outHandleToken[32];
    struct HuksBlob outToken = {
        .data = outHandleToken,
        .dataLen = sizeof(outHandleToken)
    };
    ret = g_huksHdiProxy->Init(g_huksHdiProxy, &key, &paramSet, &outHandle, &outToken);
    ASSERT_EQ(ret, HUKS_SUCCESS);
    ASSERT_EQ(outHandle.dataLen, 8);
}

/**
 * @tc.name: HuksHdiApiTest.MultiThreadTest001
 * @tc.desc: Test init key with current software huks driver(hardcoded root key) in multi thread scenario;
 * @tc.require:issueI77AT9
 * @tc.type: FUNC
 */
HWMTEST_F(HuksHdiApiTest, MultiThreadTest001, TestSize.Level0, 10)
{
    std::thread::id thisId = std::this_thread::get_id();
    std::ostringstream oss;
    oss << thisId;
    std::string thisIdString = oss.str();
    long int thread_id = atol(thisIdString.c_str());
    HUKS_TEST_LOG_I("running thread id:%ld start\n", thread_id);

    ASSERT_NE(g_huksHdiProxy, nullptr);
    ASSERT_NE(g_huksHdiProxy->Init, nullptr);
    struct HuksBlob key = {
        .data = (uint8_t *)g_initKey,
        .dataLen = sizeof(g_initKey)
    };
    struct HuksParamSet paramSet = {
        .data = (uint8_t *)g_initParamSet,
        .dataLen = sizeof(g_initParamSet)
    };
    uint8_t outHandleBuffer[12];
    struct HuksBlob outHandle = {
        .data = outHandleBuffer,
        .dataLen = sizeof(outHandleBuffer)
    };
    uint8_t outHandleToken[32];
    struct HuksBlob outToken = {
        .data = outHandleToken,
        .dataLen = sizeof(outHandleToken)
    };
    int ret = g_huksHdiProxy->Init(g_huksHdiProxy, &key, &paramSet, &outHandle, &outToken);
    ASSERT_EQ(ret, HUKS_SUCCESS);
    ASSERT_EQ(outHandle.dataLen, 8);
    HUKS_TEST_LOG_I("running thread id:%ld end\n", thread_id);
}
}